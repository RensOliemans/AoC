#+title: Advent of Code
#+author: Rens Oliemans
#+date: 2023-12-11

Ik ben op [2023-12-11 ma] gestart, en ga niet de eerdere challenges doen: ik begin gewoon met die van vandaag, oftewel Dag 11.
* Day 10
** Part One
*** Problem
Input:

#+begin_example
7-F7-
.FJ|7
SJLL7
|F--J
LJ.LJ
#+end_example

We are looking at a grid of pipes. Each element is a pipe of some sorts, or no pipe at all (=.=). The pipes are:
- =-= :: horizontal (N to S)
- =|= :: vertical (E to W)
- =J= :: bend from N to W
- =L= :: bend from N to E
- =7= :: bend from S to W
- =F= :: bend from S to E
- =S= :: start location

The pipes always form a continuous loop, and there might be disconnected pipes in the rest of the grid. The goal is to find out the distance from the start location =S= to the farthest point in the loop, measured by steps taken in the loop. In summary: find the length of the loop.

*** Solution
The idea is to start at =S=, traverse the path until we get to =S=, and take the length of the path, divided by two.

#+name: day_10_part_one
#+begin_src python :noweb yes :tangle tangle/d10p1.py :var inputfile="inputs/day10-ex.txt" :results output
  with open(inputfile) as f:
      grid = f.read().strip().split('\n')


  def find_start_location(grid):
      <<find_start_location>>


  def traverse_path(grid, initial_cell):
      """Returns the length of the path traversed by starting from cell in grid."""
      <<traverse_path>>

  S = find_start_location(grid)
  path = traverse_path(grid, S)
  print(len(path) // 2)
#+end_src

#+RESULTS: day_10_part_one
: 8

Finding the start location is easy:
#+name: find_start_location
#+begin_src python :results none
  for y, row in enumerate(grid):
      for x, char in enumerate(row):
          if char == 'S':
              return (y, x)
#+end_src

We traverse a path starting at =a= by looking at both of the adjacent cells of =a=: =b= and =c=. We choose one of them to traverse, say =b=. We now look at the two adjacent cells to =b=, which are =a= and =d=. Our /previously/ traversed cell was =a=, so we instead look at =d=, and set =previous_cell= to =b=, so that we keep traversing new cells. Whenever we end up back at =a=, we have finished our loop.

#+name: traverse_path
#+begin_src python :noweb yes :results none
  import random

  def find_adjacent_cells(grid, cell):
      """Determines what two cells are connected to one cell."""
      <<find_adjacent_cells>>

  path = [initial_cell]
  start_cells = find_adjacent_cells(grid, initial_cell)
  cell_to_traverse = random.choice(start_cells)

  previous_cell = initial_cell
  while cell_to_traverse != initial_cell:
      path.append(cell_to_traverse)
      adjacent_cells = find_adjacent_cells(grid, cell_to_traverse)
      temp = cell_to_traverse
      cell_to_traverse = [cell for cell in adjacent_cells
                          if cell != previous_cell][0]
      previous_cell = temp

  return path
#+end_src

For the code below, =find_adjacent_cells=, note that a higher =y= means that it is /lower/ in the grid.

#+name: find_adjacent_cells
#+begin_src python :noweb yes
  y, x = cell[0], cell[1]
  char = grid[y][x]
  match char:
      case "S":
          <<find_adjacent_cells_start>>
      case "|":
          return (y - 1, x), (y + 1, x)
      case "-":
          return (y, x - 1), (y, x + 1)
      case "F":
          return (y + 1, x), (y, x + 1)
      case "7":
          return (y + 1, x), (y, x - 1)
      case "L":
          return (y - 1, x), (y, x + 1)
      case "J":
          return (y - 1, x), (y, x - 1)
#+end_src

Now we only need to find out what cells are adjacent to the start position =S=. The cell has two to four neighbours, two of which are connected to it (otherwise it is no single loop). We can reuse the previous method, =find_adjacent_cells=, for all of the neighbours of =S=. There will be two neighbours which will have =S= as its adjacent cell.

#+name: find_adjacent_cells_start
#+begin_src python
  possible_neighbours = {
      (y + 1, x) if y < len(grid) else (y - 1, x),
      (y - 1, x) if y > 0 else (y + 1, x),
      (y, x + 1) if x < len(grid[0]) else (y, x - 1),
      (y, x - 1) if x > 0 else (y, x + 1),
  }

  neighbours = list()
  for neighbour in possible_neighbours:
      cells = find_adjacent_cells(grid, neighbour)
      if cells is not None and (y, x) in cells:
          neighbours.append(neighbour)

  assert len(neighbours) == 2, f"{len(possible_neighbours)} should be equal to 2"
  return neighbours
#+end_src

#+CALL: day_10_part_one(inputfile="inputs/day10.txt")

#+RESULTS:
: 6613

** Part Two

*** Problem
We need to find out how many tiles are enclosed by the loop. Look at the following input:
#+begin_example
...........
.S-------7.
.|F-----7|.
.||OOOOO||.
.||OOOOO||.
.|L-7OF-J|.
.|II|O|II|.
.L--JOL--J.
.....O.....
#+end_example

The "O"s represent being outside the loop, and the "I" represent being inside. Even more impressive, the following example has the same amount (4) of tiles inside the loop. With the next example, you can see that squeezing between two pipes is also allowed.

#+begin_example
..........
.S------7.
.|F----7|.
.||OOOO||.
.||OOOO||.
.|L-7F-J|.
.|II||II|.
.L--JL--J.
..........
#+end_example

*** Solution
Leo already told me a great way to solve this, and I'm going to do that. The idea is to count the number of pipes with a horizontal exit that you've already seen (so, that are to the left of your position). If that number is odd, you are "inside" the loop. If it's even, you are outside. See the [[https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule][Even-odd rule]].

We are cheating a bit, since we know from our input that =S= has a horizontal exit. the proper way to solve this is quite easy since we already know the path (check if the cell above =S= is in the path), but this is easier :)

#+NAME: day_10_part_two
#+begin_src python :noweb yes :tangle tangle/d10p2.py :var inputfile="inputs/day10-ex2.txt" :results output
  with open(inputfile) as f:
      grid = f.read().strip().split('\n')

  def find_start_location(grid):
      <<find_start_location>>


  def traverse_path(grid, cell):
      """Returns the length of the path traversed by starting from cell in grid."""
      <<traverse_path>>


  S = find_start_location(grid)
  path = traverse_path(grid, S)

  counter = 0
  for i, row in enumerate(grid):
      pipe_count = 0
      for j, char in enumerate(row):
          if (i, j) in path and char in ['|', 'J', 'L', 'S']:
              pipe_count += 1
          elif pipe_count % 2 == 1 and (i, j) not in path:
              counter += 1

  print(counter)
#+end_src

#+RESULTS: day_10_part_two
: 10

#+CALL: day_10_part_two(inputfile="inputs/day10.txt")

#+RESULTS:
: 511

* Day 11
** Part One
*** Problem
We have an input of the following format:

#+name: example_input
#+begin_example
...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....
#+end_example

which represents an image from a telescope. Each =.= represents an empty space, and each =#= represents a galaxy. The goal is to find the shortest distance between /each pair/ of galaxies.

The catch is that since the image was taken, the space has expanded. Area with a lot of mass expands less, so all /rows and columns/ which have /no galaxies/ expand to be twice as large. After expansion (rows 4 and 8, and columns 3, 6 and 9 have no galaxies), the universe now looks like this:

#+name: example_expanded
#+begin_example
....#........
.........#...
#............
.............
.............
........#....
.#...........
............#
.............
.............
.........#...
#....#.......
#+end_example

The goal is to calculate the distance of the shortest path between /each pair/ of galaxies, and sum them up. According to the rules the path can move over galaxies, so we can just take the Manhattan distance, which is nice.

*** Solution
The solution consists of two steps: expanding the image, and calculating the shortest paths.

#+name: day_11_part_one
#+begin_src python :noweb yes :tangle tangle/d11p1.py :var inputfile="inputs/day11-ex.txt" :results output
  def get_expansion(inputfile):
      <<expansion_one>>

  expansion = get_expansion(inputfile)

  def sum_distance(expansion):
      <<sum_distance_one>>

  print(sum_distance(expansion))
#+end_src

#+RESULTS: day_11_part_one
: 374

**** Expansion
The empty rows and columns have to be duplicated. First, find out what they are. The rows are easy, and the columns are as well after a short transpose. [[https://docs.python.org/3.8/library/functions.html#zip][zip]] returns iterables of zipped rows, where each iterable has the elements of a column. To get each column as a string, we can just do =''.join(col)=.

#+name: expansion_one
#+begin_src python :results none
  with open(inputfile) as f:
      puzzle = f.read().strip()
  rows = puzzle.split('\n')

  empty_rows = [index for index, row in enumerate(rows) if not '#' in row]
  empty_row = ".".join(['' for i in range(len(rows[0]) + 1)])
  for i in empty_rows[::-1]:
      rows.insert(i, empty_row)

  cols = [''.join(col) for col in zip(*rows)]
  empty_cols = [index for index, col in enumerate(cols) if not '#' in col]
  empty_col = ".".join(['' for i in range(len(cols[0]) + 1)])
  for i in empty_cols[::-1]:
      cols.insert(i, empty_col)


  rows = [''.join(row) for row in zip(*cols)]
  return '\n'.join(rows)
#+end_src

**** Calculating shortest path
OK now we need to calculate the shortest paths of all pairs of galaxies. For calculating the Manhattan distance, we need the coordinates of all galaxies. Then, we need to iterate over all /pairs of galaxies/ ([[https://docs.python.org/3/library/itertools.html#itertools.combinations][itertools.combinations]]) and calculate the distance for each pair. Finally, we sum that up.
#+name: sum_distance_one
#+begin_src python :results none
  from itertools import combinations

  galaxies = list()
  for y, row in enumerate(expansion.split('\n')):
      for x, char in enumerate(row):
          if char == '#':
              galaxies.append((x, y))

  pairs = list(combinations(galaxies, r=2))

  total = 0
  for p1, p2 in pairs:
      total += abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

  return total
#+end_src

#+NAME: day_11_part_one_main
#+CALL: day_11_part_one(inputfile="inputs/day11.txt")

#+RESULTS: day_11_part_one_main
: 9974721

** Part Two
This problem is identical, except that now the galaxies have moved /much farther/ away from each other. Whereas before we had to duplicate the rows and cols (ie, add /one/ row for each empty row), now we have to add 1.000.000 empty rows for each empty row (and col).

The naive way to do this is to simply convert each empty row to 1.000.000 empty rows and calculate the distance in the expanded image. However, we don't need this and is horribly inefficient. Instead, we save the empty rows and columns (by index, f.e. =[2, 5, 8]=), and when calculating the distance, we check how many empty rows and columns the galaxies have between them. For each one of them, we add 1.000.000 to the sum of distances.

This solution generalises the previous one (=expansionfactor= of =2=).

#+NAME: day_11_part_two
#+begin_src python :noweb yes :tangle tangle/d11p2.py :var inputfile="inputs/day11-ex.txt" :var expansionfactor=2 :results output
  with open(inputfile) as f:
      puzzle = f.read().strip()

  def get_empty_rows_cols(puzzle):
      <<empty_rows_cols>>

  empty_rows, empty_cols = get_empty_rows_cols(puzzle)

  def sum_distance(puzzle, empty_rows, empty_cols, expansionfactor):
      <<new_sum_distance>>

  print(sum_distance(puzzle, empty_rows, empty_cols, expansionfactor))
#+end_src

#+RESULTS:
: 374

We can copy the finding of =empty_rows / empty_cols= from Part One:

#+name: empty_rows_cols
#+begin_src python :results none
  rows = puzzle.split('\n')
  empty_rows = [index for index, row in enumerate(rows) if not '#' in row]

  cols = [''.join(col) for col in zip(*rows)]
  empty_cols = [index for index, col in enumerate(cols) if not '#' in col]

  return empty_rows, empty_cols
#+end_src

Now that we have the empty rows and columns, let's modify our calculation part so that we count the expanded rows and columns. I am going to use [[https://docs.python.org/3/library/bisect.html][bisect]] for this since it's fast.

The way I do this is to look at each pair, f.e. =((5,0), (7,1))=. For each pair determine =x_min= and =x_max=, in the example =5= and =7=. The highest index of an empty row can be found by doing =bisect_right(empty_rows, x_max)=. The lowest index of an empty row can be found by doing =bisect_left(empty_rows, x_min)=. Having these indices is great, since the /amount/ of empty rows is simply =highest_index - lowest_index=, or in the code below, =last_empty_row - first_empty_row=. Analogous to columns, and you have the amount of empty rows and columns between the pair of galaxies, which you can multiply by =expansionfactor - 1= to get the effect of converting =1= empty row/column to =expansionfactor= empty rows/columns. 

#+name: new_sum_distance
#+begin_src python :results none
  from itertools import combinations
  import bisect

  galaxies = list()
  for x, row in enumerate(puzzle.split('\n')):
      for y, char in enumerate(row):
          if char == '#':
              galaxies.append((x, y))

  pairs = list(combinations(galaxies, r=2))

  total = 0
  for p1, p2 in pairs:
      x_min, x_max = min(p1[0], p2[0]), max(p1[0], p2[0])
      first_empty_row = bisect.bisect_left(empty_rows, x_min)
      last_empty_row = bisect.bisect_right(empty_rows, x_max)
      empty_rows_between = last_empty_row - first_empty_row
      x = x_max - x_min + empty_rows_between * (expansionfactor - 1)

      y_min, y_max = min(p1[1], p2[1]), max(p1[1], p2[1])
      first_empty_col = bisect.bisect_left(empty_cols, y_min)
      last_empty_col = bisect.bisect_right(empty_cols, y_max)
      empty_cols_between = last_empty_col - first_empty_col
      y = y_max - y_min + empty_cols_between * (expansionfactor - 1)

      total += x + y

  return total
#+end_src

#+NAME: day_11_part_two_main
#+CALL: day_11_part_two(inputfile="inputs/day11.txt", expansionfactor=1000000)

#+RESULTS: day_11_part_two_main
: 702770569197
