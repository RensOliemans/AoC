#+TITLE: Advent of Code 2024
#+AUTHOR: Rens Oliemans
#+DESCRIPTION: My Advent of Code solutions for 2024
#+STARTUP: overview
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]

Finding the Chief Historian! This program contains my [[https://adventofcode.com/][Advent of Code]] solutions for 2024, which you can find on my [[https://sr.ht/~rensoliemans/AoC/][sourcehut]] and [[https://github.com/RensOliemans/AoC/][GitHub]]. I believe GitHub doesn't show the results of code blocks, which means that viewing it there might leave you a bit confused.

In general, I've added line numbers to code blocks when that code block is part of the solution file. In some cases, I've added code to explain, clarify, justify or otherify something, and these lines aren't necessary to the final solution and thus aren't numbered.
#+LATEX: \clearpage

* Utils
:PROPERTIES:
:header-args: :tangle util.clj
:header-args:clojure: :session *clojure-util* :results silent
:END:

I have some common functions in =aoc.util=, mostly related to parsing the input. The input always comes in a file but also usually has an example input. The former is a file (which we read as a string with =slurp= and the latter is just the string itself. Therefore it's easiest to let the days itself take care of reading the file (since they also have the example input), and just operate on strings.

#+begin_src clojure -n -r
  (ns aoc.util
    (:require [clojure.string :as str]))
#+end_src

#+begin_src clojure +n 1
  (defn string-as-lines
    "Outputs the string as a vector, one element per line."
    [input]
    (str/split input #"\n"))
#+end_src

Often the lines contain numbers:
#+begin_src clojure +n 1
  (defn string-as-numbers-per-line
    "Assumes there is a number on each line: we parse it and return a
    vector, one element per line. Technically each number is parsed with
    `read-string`, so it isn't just limited to numbers, but I've only
    tested numbers."
    [input]
    (let [lines (string-as-lines input)]
      (map read-string lines)))
#+end_src

or lists of numbers. This was the case in both [[*Day 1][Day 1]] and [[*Day 2][Day 2]], where the input had the following format:
#+NAME: util-testtable
#+begin_example
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
#+end_example
Here, we want the whole file to be represented by a vector, where each element is itself a vector of the space-separated numbers on a line.
#+NAME: num-list-per-line
#+begin_src clojure +n 1
  (defn num-list-per-line
    "Returns a vector of vectors, the outer vector has an element per
    line, the inner has space-separated elements. "
    [input]
    (let [lines (string-as-lines input)]
      (->> lines
           (map #(str/split % #"\s+"))
           (map #(map read-string %)))))
#+end_src

This function, outputted on the example table seen above, will return the following:
#+header: :var example=util-testtable
#+begin_src clojure :results value replace :tangle no :exports both
  (num-list-per-line example)
#+end_src

#+RESULTS:
: ((7 6 4 2 1) (1 2 7 8 9) (9 7 6 2 1) (1 3 2 4 5) (8 6 4 4 1) (1 3 6 7 9))

* Day 1
:PROPERTIES:
:header-args: :tangle src/day1.clj :exports both
:header-args:clojure: :session *clojure-1* :var testinput=testinput1
:END:

** Part 1
We need to reconcile two lists. We get them in the following form:

#+NAME: testinput1
#+begin_example
3   4
4   3
2   5
1   3
3   9
3   3
#+end_example
And our goal is to find the "distance" between the two lists.
#+begin_quote
To find the total distance between the left list and the right list, add up the distances between all of the [sorted] pairs you found.
#+end_quote
For the example above, the correct answer is *11*.

My strategy is: convert the input to pairs of numbers ([[num-list-per-line][=aoc.util/num-list-per-line=]] takes care of this), transpose them (so we have two lists), sort them, transpose them again (pairs), and take the difference and sum it.

I'm going to transpose these lists, sort them, transpose them again, take the difference, and sum it.
Makes sense? We need the two tiny helper functions =sum= and =transpose=:
#+begin_src clojure -n -r :results silent
  (ns aoc.1)
#+end_src

#+begin_src clojure +n 1 :results silent
  (defn- sum "Finds the sum of a vector of numbers" [vec]
    (reduce + vec))

  (defn- transpose "Transposes a matrix" [m]
    (apply mapv vector m))
#+end_src

With the final function being now quite easy to follow if you keep my strategy above in mind.
Recall that the correct answer for the testinput was 11.
#+begin_src clojure +n 1
  (defn p1 [input]
    (let [input (aoc.util/num-list-per-line input)]
      (->> input
           (transpose)
           (map sort)
           (transpose)
           (map #(abs (- (first %) (second %))))
           (sum))))

  (p1 testinput)
#+end_src

#+RESULTS:
: 11

It works for the testinput, fantastic. Now let's open the file and run it on the input.
The input file for day 1 can be found in the file =inputs/1=.

#+begin_src clojure +n 1
  (def input (slurp "inputs/1"))
  (p1 input)
#+end_src

#+RESULTS:
: 2057374

Hurrah! We get a *Gold Star*!

** Part 2
Now, we need to find a "similarity score" for the two lists:
#+begin_quote
Calculate a total similarity score by adding up each number in the left list after multiplying it by the number of times that number appears in the right list.
#+end_quote

A naive way to do this would be to iterate over the first list, where, for each element, we count how many items in the second list are equal to that element, and multiply the element with the count.
However, you'd be doing a lot of duplicate counting.
A faster way to do it is to convert the second (it doesn't really matter which one you pick) list to a map once, with ={element frequency}=.
Let's use the function =frequencies=!

#+begin_src clojure :tangle no
  (frequencies (last (transpose (aoc.util/num-list-per-line testinput))))
#+end_src

#+RESULTS:
: {4 1, 3 3, 5 1, 9 1}

Now, we can iterate over the first list (which we get by ~(transpose (numbers input))~), multiply the element itself by the count in =frequencies=, and sum the result.

#+begin_src clojure +n 1
  (defn p2 [input]
    (let [input (transpose (aoc.util/num-list-per-line input))
          one (first input)
          freqs (frequencies (second input))]
      (->> one
           (map #(* % (freqs % 0)))
           (sum))))

  (assert (= 31 (p2 testinput)))
  (p2 input)
#+end_src

#+RESULTS:
: 23177084
#+LATEX: \clearpage

* Day 2
:PROPERTIES:
:header-args: :tangle src/day2.clj :exports both :var testinput=testinput2
:header-args:clojure: :session *clojure-2*
:END:

** Part 1
Analysing some unusual data from a nuclear reactor. The data consists of /reports/ separated by lines, each of which is a list of numbers (/levels/), separated by spaces.

#+NAME: testinput2
#+begin_example
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
#+end_example

We need to find out how many reports are *safe*, which is the case if all levels are gradually increasing or decreasing. This is defined as such:
#+begin_quote
[A] report only counts as safe if both of the following are true:

 - The levels are either all increasing or all decreasing.
 - Any two adjacent levels differ by at least one and at most three.
#+end_quote
In the example input, there are *2* safe reportsâ€”the first and last.

Let's convert all numbers to the difference between the previous number.
Then, a report is safe is all numbers are of the same sign, and the absolute of the number is between 1 and 3.

Since we're computing the difference between each element and the element before, I want to use =partition=, which does exactly this. Then, we can use =mapv= to compute the difference. For the last element of the testinput:
#+begin_src clojure -n -r :results silent
  (ns aoc.2)
#+end_src

#+begin_src clojure +n 1 :results silent
  (defn diffs [record]
    (->> record
         (partition 2 1)
         (mapv (fn [[a b]] (- b a)))))
#+end_src
test it out:
#+begin_src clojure
  (diffs (last (aoc.util/num-list-per-line testinput)))
#+end_src

#+RESULTS:
: [2 3 1 2]


Now just use that to determine whether a record is safe. Recall that the testinput had *2* safe records.
#+begin_src clojure +n 1
  (defn is-safe? [record]
    (let [differences (diffs record)]
      (and (every? #(<= 1 (abs %) 3) differences)
           (apply = (map pos? differences)))))

  (defn p1 [input]
    (->> (aoc.util/num-list-per-line input)
         (filter is-safe?)
         (count)))

  (p1 testinput)
#+end_src

#+RESULTS:
: 2

#+begin_src clojure +n 1
  (def input (slurp "inputs/2"))
  (p1 input)
#+end_src

#+RESULTS:
: 242

ðŸ˜Ž

** Part 2
#+begin_quote
Now, the same rules apply as before, except if removing a single level from an unsafe report would make it safe, the report instead counts as safe.
#+end_quote
First I had a smart idea. Check out [[https://git.sr.ht/~rensoliemans/AoC/commit/e2dcab2f0de76c21477c5e871e029f0282c8fabc][e2dcab2f0de76c21477c5e871e029f0282c8fabc]]. It is much more efficient than the current solution, but much more convoluted and ugly to read. Right now, I just remove each level one by one and check if the record is safe then.

#+begin_src clojure +n 1
  (defn drop-nth [coll n]
    (keep-indexed #(if (not= %1 n) %2) coll))

  (defn dampened-is-safe? [record]
    (some is-safe? (map #(drop-nth record %)
                        (range (count record)))))

  (defn p2 [input]
    (->> (aoc.util/num-list-per-line input)
         (filter dampened-is-safe?)
         (count)))

  (p2 testinput)
#+end_src

#+RESULTS:
: 4

#+begin_src clojure +n 1
  (p2 input)
#+end_src

#+RESULTS:
: 311

*** Benchmark results
The [[https://git.sr.ht/~rensoliemans/AoC/commit/e2dcab2f0de76c21477c5e871e029f0282c8fabc][old solution]] took on average =3.8= milliseconds to execute ~(p2 input)~, and the new solution about =6.0=. This is worth it, IMO, since the code is /much/ simpler. Next time, first do the easy thing, and then benchmark to see if it needs to be improved!
#+LATEX: \clearpage
* Day 3
:PROPERTIES:
:header-args: :tangle src/day3.clj :exports both
:header-args:clojure: :session *clojure-3*
:END:
** Part 1
We have an input string that contains a lot of characters, for example:
#+begin_example
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
#+end_example

The goal is to extract all substrings that are of the exact form =mul(\d+,\d+)=, and in that case multiply the two numbers together. This is straightforward, I'm not really going to create any helper functions: parse with regex, convert to int, multiply and sum.
#+begin_src clojure -n -r :results silent
  (ns aoc.3)
#+end_src

#+begin_src clojure +n 1 :results silent
  (defn p1 [input]
    (let [matches (re-seq #"mul\((\d+),(\d+)\)" input)]
      (->> matches
           (map #(list (Integer/parseInt (nth % 1)) (Integer/parseInt (nth % 2))))
           (map #(apply * %))
           (reduce +))))
#+end_src

#+begin_src clojure +n 1
  (let [input (slurp "inputs/3")]
    (p1 input))
#+end_src

#+RESULTS:
: 155955228

** Part 2
We get a new example string for Part Two:
#+begin_example
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
#+end_example

This contains the substrings =don't()= and =do()=, which disable and enable =mul()= instructions. I can do fancy clojure things, but Emacs is way too good for this, so let's do it quickly in Elisp. We want to remove everything from the input file that's in between a =don't()= and a =do()= instruction, and then call =(p1)= on this input.
There are three slightly tricky things about this:
- The input file has some newlines, and in some cases a =do()= instruction is on a later line
  than the previous =don't()= instruction.
- You need to match non-greedy in between a =don't()= and a =do()=.
- If you call =(replace-regexp)= with just the regex and replacement string, it will move
  point to the last match. This is easily fixed by adding the fourth and fifth arguments to
  =replace-regexp=: =START= and =END=.
#+begin_src elisp :results none
  ;; elisp
  (with-temp-buffer
    (insert-file-contents "inputs/3")
    (replace-regexp "\n" "" nil (point-min) (point-max))
    (replace-regexp "don't().+?do()" "" nil (point-min) (point-max))
    (write-region (point-min) (point-max) "inputs/3-enabled"))
#+end_src

#+begin_src clojure +n 1
  ;; back to clojure
  (let [fixed-input (slurp "inputs/3-enabled")]
    (p1 fixed-input))
#+end_src

#+RESULTS:
: 100189366
